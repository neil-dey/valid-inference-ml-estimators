import numpy as np
import scipy.stats as st
import matplotlib.pyplot as plt
from scipy.optimize import fsolve
import multiprocessing as mp

np.set_printoptions(threshold=np.inf)

def conf_seq(data, alpha):
    def u(t, alpha):
        return 0.72*(t**-1 * (1.4 * np.log(np.log(2.04 * t)) + np.log(9.97/alpha)))**0.5

    b = u(len(data), alpha)
    if b > 0.5:
        return (0, 1)

    return (np.quantile(data, 0.5 - b), np.quantile(data, 0.5 + b))

def unif_conf(data, alpha):
    # https://papers.nips.cc/paper_files/paper/2015/file/fbd7939d674997cdb4692d34de8633c4-Paper.pdf
    c = 2
    m = len(data)
    epsilon = fsolve(lambda x: m - c/x**2 * np.log(1/x) + c/x**2 * np.log(alpha), x0 = 0.1, fprime = lambda x: (-2*c*np.log(alpha) + 2*c*np.log(1/x)+ c)/x**3)[0]

    med = np.quantile(data, 0.5)
    return (max(0, med - 2*epsilon), min(1, med + 2*epsilon))

def gim_conf(data, alpha):
    def T_S(data, theta):
        median = np.quantile(data, 0.5)
        return np.mean([abs(x - theta) for x in data]) - np.mean([abs(x - median) for x in data])
    tss = []
    for _ in range(100):
        boot_data = np.random.choice(data, len(data), replace = True)
        tss.append(T_S(boot_data, np.quantile(data, 0.5)))

    G = st.ecdf(tss).cdf.evaluate

    lb = 0
    ub = 1
    ThetaSpace = np.linspace(0, 1, 100)

    for theta in ThetaSpace:
        if 1 - G(T_S(data, theta)) >= alpha:
            lb = theta
            break
    for theta in ThetaSpace[::-1]:
        if 1 - G(T_S(data, theta)) >= alpha:
            ub = theta
            break
    return (lb, ub)



sample_size = 1000
def mc_iter(seed):
    np.random.seed(seed)

    alpha = 0.05
    P = st.beta(0.1, 0.1)
    median = 0.5 #np.quantile(P.rvs(size = 10000), 0.5 )

    g_widths = np.zeros(sample_size//10)
    r_widths = np.zeros(sample_size//10)
    u_widths = np.zeros(sample_size//10)

    g_coverages = np.zeros(sample_size//10)
    r_coverages = np.zeros(sample_size//10)
    u_coverages = np.zeros(sample_size//10)

    data = []
    for i in range(sample_size):
        data.append(P.rvs())
        if i % 10 != 0:
            continue

        lb, ub = gim_conf(data, alpha)
        g_widths[i//10] += (ub - lb)
        g_coverages[i//10] += (lb < median < ub)

        lb, ub = conf_seq(data, alpha)
        r_widths[i//10] += (ub - lb)
        r_coverages[i//10] += (lb < median < ub)

        lb, ub = unif_conf(data, alpha)
        u_widths[i//10] += (ub - lb)
        u_coverages[i//10] += (lb < median < ub)

    return (g_widths, g_coverages, r_widths, r_coverages, u_widths, u_coverages)


mc_iters = 1000
"""
with mp.Pool(4) as p:
    results = p.map(mc_iter, [_ for _ in range(mc_iters)])

    gims_widths = np.mean([r[0] for r in results], axis = 0)
    gims_coverages = np.mean([r[1] for r in results], axis = 0)
    ramdas_widths = np.mean([r[2] for r in results], axis = 0)
    ramdas_coverages = np.mean([r[3] for r in results], axis = 0)
    unif_widths = np.mean([r[4] for r in results], axis = 0)
    unif_coverages = np.mean([r[5] for r in results], axis = 0)
    print(gims_widths)
    print(gims_coverages)
    print(ramdas_widths)
    print(ramdas_coverages)
    print(unif_widths)
    print(unif_coverages)
"""

# Final results
gims_widths = [1., 0.78852525, 0.78935354, 0.78988889, 0.78615152, 0.77392929, 0.76357576, 0.76047475, 0.74726263, 0.73717172, 0.72760606, 0.72210101, 0.70819192, 0.69656566, 0.68481818, 0.67493939, 0.66594949, 0.65484848, 0.64549495, 0.6360303, 0.62543434, 0.61743434, 0.60448485, 0.60008081, 0.59292929, 0.58311111, 0.57755556, 0.56658586, 0.55993939, 0.55381818, 0.5469798, 0.5429697, 0.53423232, 0.52652525, 0.52356566, 0.51943434, 0.51117172, 0.50825253, 0.50182828, 0.49726263, 0.49148485, 0.48510101, 0.47888889, 0.4759697, 0.47045455, 0.46540404, 0.46227273, 0.45855556, 0.45289899, 0.44956566, 0.4449697, 0.44285859, 0.4379596, 0.43372727, 0.42950505, 0.42905051, 0.42538384, 0.42050505, 0.41672727, 0.4150303, 0.41416162, 0.40978788, 0.40589899, 0.40366667, 0.40045455, 0.39677778, 0.3939798, 0.39408081, 0.38860606, 0.38647475, 0.38647475, 0.38048485, 0.37805051, 0.37860606, 0.37508081, 0.37530303, 0.37152525, 0.37113131, 0.36670707, 0.36380808, 0.36330303, 0.36249495, 0.35954545, 0.35727273, 0.35627273, 0.35352525, 0.3539798, 0.34992929, 0.34860606, 0.34714141, 0.34347475, 0.34246465, 0.33982828, 0.34167677, 0.3379899, 0.33711111, 0.33444444, 0.33285859, 0.33052525, 0.32856566]
gims_coverages = [1., 0.797, 0.817, 0.835, 0.849, 0.853, 0.858, 0.873, 0.87, 0.886, 0.879, 0.889, 0.906, 0.896, 0.899, 0.896, 0.905, 0.893, 0.908, 0.905, 0.91, 0.912, 0.901, 0.914, 0.902, 0.902, 0.913, 0.909, 0.917, 0.917, 0.922, 0.92, 0.917, 0.92, 0.923, 0.926, 0.917, 0.922, 0.918, 0.924, 0.913, 0.922, 0.917, 0.928, 0.923, 0.919, 0.919, 0.92, 0.92, 0.922, 0.924, 0.925, 0.927, 0.926, 0.924, 0.924, 0.93, 0.923, 0.929, 0.931, 0.926, 0.924, 0.926, 0.916, 0.92, 0.916, 0.91, 0.926, 0.912, 0.916, 0.923, 0.922, 0.92, 0.92, 0.915, 0.921, 0.916, 0.922, 0.926, 0.924, 0.935, 0.929, 0.931, 0.934, 0.939, 0.926, 0.933, 0.924, 0.921, 0.931, 0.939, 0.93, 0.929, 0.927, 0.93, 0.932, 0.933, 0.934, 0.929, 0.938]

ramdas_widths = [1., 1., 0.99779687, 0.9970681, 0.99459477, 0.99095503, 0.98806593, 0.98373386, 0.97999988, 0.9760137, 0.97059017, 0.96576616, 0.96063804, 0.95537161, 0.94944848, 0.94300909, 0.9374194, 0.93178953, 0.92573062, 0.92008096, 0.91463418, 0.90812309, 0.90234249, 0.89650764, 0.89065069, 0.8855488, 0.88055922, 0.87479373, 0.86943136, 0.86378742, 0.85887633, 0.85338298, 0.84763241, 0.84310405, 0.83809853, 0.83354816, 0.82871247, 0.82398517, 0.81958561, 0.81485951, 0.81041419, 0.80527504, 0.80113261, 0.79708158, 0.79280376, 0.78834626, 0.7837277, 0.77974248, 0.77497049, 0.77142447, 0.76722448, 0.76312572, 0.75893538, 0.75507094, 0.75165481, 0.74809421, 0.74445054, 0.74056495, 0.73711488, 0.73362463, 0.73030948, 0.72675906, 0.7240459, 0.72042963, 0.71704337, 0.71378604, 0.71078143, 0.70741597, 0.70426016, 0.70113396, 0.69783147, 0.69505522, 0.69221361, 0.68934168, 0.68660084, 0.68355837, 0.68084172, 0.67783092, 0.67478233, 0.67236478, 0.66968862, 0.66700875, 0.66436994, 0.6622316, 0.65955031, 0.65686887, 0.65443461, 0.65179711, 0.64930339, 0.64730189, 0.64510862, 0.64200787, 0.63979278, 0.63761603, 0.63500813, 0.63249202, 0.63007906, 0.6281116, 0.6258548, 0.62386582]
ramdas_coverages = [1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]

unif_widths = [1., 1., 1., 0.99911158, 0.98065981, 0.95892673, 0.9400235, 0.92404728, 0.90701859, 0.89403651, 0.87955087, 0.86873812, 0.85580242, 0.8436428, 0.8323997, 0.81983968, 0.80753632, 0.79611504, 0.78763133, 0.78001758, 0.77102961, 0.7603277, 0.75010705, 0.74125385, 0.73209523, 0.72421357, 0.71696922, 0.70911187, 0.70102037, 0.6925468, 0.6849842, 0.67748921, 0.66937923, 0.66283672, 0.65582493, 0.64906482, 0.64164784, 0.63543442, 0.62846719, 0.62222515, 0.6158024, 0.60943756, 0.60358887, 0.59783779, 0.59197269, 0.58639836, 0.58088316, 0.57581878, 0.57071484, 0.56570789, 0.56093426, 0.55594342, 0.55117793, 0.54656832, 0.54184907, 0.53749218, 0.53322695, 0.52919789, 0.525213, 0.5212512, 0.51745991, 0.51368105, 0.50993615, 0.506312, 0.50279718, 0.49934393, 0.4959207, 0.4925766, 0.48928289, 0.48603581, 0.48292553, 0.47978394, 0.47675645, 0.47378317, 0.47087957, 0.46803307, 0.465187, 0.4624299, 0.45974215, 0.45709145, 0.45446933, 0.45189655, 0.44939122, 0.44691937, 0.44450489, 0.44211681, 0.43975159, 0.43745164, 0.43518415, 0.4329488, 0.4307495, 0.42858528, 0.42645521, 0.42435838, 0.42229394, 0.42026103, 0.41825887, 0.41628667, 0.41434368, 0.41242919]
unif_coverages = [1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0.999, 0.997, 0.997, 0.995, 0.998, 0.997, 0.997, 0.997, 0.995, 0.992, 0.992, 0.994, 0.991, 0.991, 0.99, 0.989, 0.991, 0.992, 0.992, 0.993, 0.994, 0.994, 0.993, 0.992, 0.992, 0.994, 0.992, 0.992, 0.989, 0.991, 0.993, 0.992, 0.992, 0.992, 0.989, 0.99, 0.986, 0.985, 0.986, 0.985, 0.986, 0.987, 0.987, 0.987, 0.987, 0.987, 0.986, 0.99, 0.99, 0.987, 0.987, 0.986, 0.988, 0.985, 0.985, 0.984, 0.982, 0.984, 0.986, 0.985, 0.988, 0.989, 0.987, 0.986, 0.987, 0.988, 0.987, 0.987, 0.986, 0.988, 0.987, 0.987, 0.987, 0.988, 0.989, 0.988, 0.987, 0.989, 0.986, 0.988, 0.99, 0.988]

ns = [i+1 for i in range(sample_size) if i % 10 == 0]

plt.scatter(ns, ramdas_widths, label = 'Howard & Ramdas')
plt.scatter(ns, gims_widths, marker = "+", label = "GIM")
plt.scatter(ns, unif_widths, marker = "^", label = 'AERM')
plt.xlabel('Sample Size')
plt.ylabel('Avg. Width')
plt.ylim(0, )
plt.legend()
plt.savefig("median_width.png")

plt.clf()
plt.scatter(ns, ramdas_coverages, label = 'Howard & Ramdas')
plt.scatter(ns, gims_coverages, marker = "+", label= "GIM")
plt.scatter(ns, unif_coverages, marker = "^", label = 'AERM')
plt.plot(ns, [0.95 for _ in ns], linestyle = 'dashed', color = 'black')
plt.xlabel('Sample Size')
plt.ylabel('Coverage')
plt.legend()
plt.savefig("median_coverage.png")
